~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|...............................................................................................|
|------------------- Instruction / algorithm how I created my cms based on mvc -------------------|
|...............................................................................................|
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---------------------------------------- Content ---------------------------------------------

1) Setting up the environment "Docker - Compose"
2) Template
3) Creation of MVC and construction itself for the application

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

----------------------------------------- The basis -----------------------------------------------

-----------------------------------------
1) Setting up the environment "Docker - Compose"
-----------------------------------------
We decide what we need for our cms. And this is the server, let's take nginx. The php-fpm interpreter language itself, and mysql.
In general, we put something like LEMP
Next we need git and composer......

---------------
a) docker-compose.yml
---------------
Create a file called docker-compose.yml and write in it
# this is how comments are marked
# From the beginning we set the version of the docker composer
version: '3.7'

# Here we go further what services we want to run. The so-called instruction
# The name of the services can be anything, but to make it logically clear what instructions there will be php: or mysql:
services:
# Set up a server
  nginx:
    build:
    # Specify the path where the settings (installation rules) of the server are located
      context: ./docker/nginx
    volumes:
    # We write the path to our project and container, where ./ is the path to access this folder on the computer.
    # Colon means "to" our computer : virtual machine
      - ./:/var/www/app
    ports:
    # Registered ports. To have such an address https://locallhost/ you need to use port 80
      - "80:80"

# Next we have a language interpreter
    php fpm:
        build:
         # Specify the path where the settings (installation rules) of the php language interpreter are located
          context: ./docker/php-fpm
        volumes:
        # We write the path to our project and container, where ./ is the path to access this folder on the computer.
        # Colon means "to" our computer : virtual machine
          - ./:/var/www/app
        environment:
        # setup XDEBUG for ubuntu/phpstorm. The path is written to the .env file
          PHP_IDE_CONFIG: serverName=${SERVER_NAME}
        env_file:
        # path for .env there are settings/passwords/etc. our environment. This line works for everything
          - .env
        networks:
          default:
          # Specify ip for applications to interact with each other
            ipv4_address: ${PHP_FPM_IP}

# Next comes mysql database
    mysql:
    # We take the finished assembly from https://hub.docker.com/
        image:mysql:8.0
        environment:
        # Set the DATABASE name and root password. It is stored in .env file
          MYSQL_DATABASE: ${DB_NAME}
          MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
          # Set the setting, details here
          # https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password-root-account
        command: --default-authentication-plugin=mysql_native_password
        volumes:
        # The database will be stored in docker
          - mysql_data:/var/lib/mysql
          # copying database commands to the virtualization folder (such as the minimum table that should be on the virtualization table and filling it)
          - ./init.sql:/docker-entrypoint-initdb.d/init.sql
        ports:
        # In which ports does 1 to 1 work
          - "3306:3306"
        networks:
          default:
          # ip address for interaction between programs. It is stored in .env file
            ipv4_address: ${MYSQL_IP}

# Next comes the rules for the interaction between programs
     networks:
       default:
       # connection is made over the bridge system
         driver:bridge
         ipam:
           config:
           # network between containers
             - subnet: ${NETWORK_SUBNET}
     volumes:
     # db is stored in docker
       mysql_data:

---------------
b) Setting up nginx in docker/nginx
---------------
---
We write this in the Dockerfile
---
    # Set architecture from dockerhub https://hub.docker.com/
FROM nginx:1.21-alpine
    # specify the settings are copied from - to
COPY ./conf.d /etc/nginx/conf.d
    # Specify the working directory in the virtual machine
WORKDIR /var/www/app

---
Further, our server settings are located in the docker/nginx/conf.d/ folder
Create a default.conf file and write this
---
# This block means that we will serve some host
server {
# listen on the port all the time. (working port)
    listen 80;
# What files to consider by default initial what to open
    index index1.php index.html;
# Our url
    server_name 127.0.0.1 localhost;
# Which folder to work with. Where start/ entry point / Path where index... will look for...
    root /var/www/app/public;

# All requests will only be made to index.php (handling / )
    location / {
# Checks if not index.php then redirects to index.php
        try_files $uri /index.php?$args;
    }

# Since we do not have php in nginx, thanks to the composer, we indicate the path to it (php processing)
    location ~ \.php$ {
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php-fpm:9000;
        fastcgi_index index1.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    error_log /var/log/nginx/project_error.log;
    access_log /var/log/nginx/project_access.log;
}


---------------
c) Setting up the php language interpreter in docker/php-fpm
---------------
---
We write this in the Dockerfile
---
# Set the architecture from dockerhub https://hub.docker.com/
FROM php:7.4-fpm-alpine

# Run commands for additional installation of add. programs (all the same as writing on the command line in Linux)
RUN apk update && apk add unzip autoconf g++ make \
    && pecl install xdebug \
    && docker-php-ext-install pdo_mysql && docker-php-ext-enable xdebug

# rename the file
RUN mv $PHP_INI_DIR/php.ini-development $PHP_INI_DIR/php.ini

# copy from our folder to the virtual machine settings
COPY ./conf.d /usr/local/etc/php/conf.d
COPY www.conf /usr/local/etc/php-fpm.d/

# give root rights (so that it would be possible to create and delete)
USER 1000:1000

# Working directory
WORKDIR /var/www/app

---
Create a www.conf file this is the configuration file for our php
---
[www]
user=www-data
group = www-data
clear_env=no
listen=9000
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3

---
Create xdebug.ini file in docker/php-fpm/conf.d folder
---
[xdebug]

xdebug.start_with_request = yes
xdebug.discover_client_host = 1
# For good display
xdebug.mode= debug, develop
# port standard 9003
xdebug.client_port=9003
# 172.17.0.1 remote debug host ifconfig look for docker0 partition:
xdebug.client_host=172.17.0.1
# so that the backlight is beautiful
integer xdebug.cli_color = 1
# In principle, this is in the env file, but I decided to add it here
xdebug.idekey= PHPSTORM


---------------
d) .env file
---------------
In the .env file, here we store the settings / passwords specifically for our working environment. We can easily change it if necessary.

# MySQL login settings
DB_PASSWORD=test
DB_NAME=app

# network between containers
NETWORK_SUBNET=172.25.0.0/24
PHP_FPM_IP=172.25.0.3
MYSQL_IP=172.25.0.6

# XDEBUG settings for ubuntu/ phpstorm
SERVER_NAME=www

Create a .env-example file for git, there will be an example of settings

---------------
d) init.sql file
--------------
---
We create an init.sql file for our database to create the initial database to work with our application
---

CREATE USER 'admin'@'172.25.0.6' IDENTIFIED BY 'test';
GRANT ALL ON *.* TO 'admin'@'172.25.0.6';
FLUSH PRIVILEGES;
# If you need a table, here is an example of how to create it in the comment
# CREATE TABLE test(
# id int auto_increment primary key, col1 datatype,
# tile varchar(255) not null
#);
# INSERT INTO test(tile)
#VALUES
# ('text1'), ('text2');

---------------
e) The .gitignore file
--------------
---
Well, everything is simple. Files that shouldn't be in github
---
.idea/
.env
vendor/

---------------
f) Composer.json file
--------------
{
  "authors": [
    {
      "name": "Pasha Karpunin",
      "email": "amedomaro2@gmail.com"
    }
  ],

  "autoload": {
    "psr-4": {
      "App\\": "src/"
    },
    "files": ["helpers.php", "config/init.php"]
  },

  "require": {
    "gabordemooij/redbean": "dev-master"
  }
}
---------------
g) Project folder structure
--------------
src -> Controllers
.... -> Models
.... ->Utils
tmp->cache
view -> errors
.... -> layouts
.... -> main
vendor - (will automatically appear)
public -> pic
  .... -> css
  .... -> js
config

This is the initial folder structure, we will add more as needed.
---------------
h) Run "Docker - Compose"
--------------
To run the build first to create an image
# docker-compose build

This is done once to create an image, you can, of course, immediately run it using the docker-compose up --build command
But sometimes artifacts occur. So just build first. Then launch
# docker-compose up

To check in the index.php file, paste this code
---

// phpinfo();

//ini_set('xdebug.var_display_max_children', 3 );
//$c = new stdClass;
//$c->foo = 'bar';
//$c->file = fopen( '/etc/passwd', 'r' );
//var_dump(
// array(
// array(TRUE, 2, 3.14, 'foo'),
// 'object' => $c
// )
//);

---
We check that everything works, everything is OK !!!
Now install composer so that all dependencies and autoloader work for us
# composer install

The vendor folder appears, which means everything is OK, everything is installed.
To update your data there, give the command
# composer dumpautoload

When everyone has finished the work, we stop the docker.
# docker-compose down

---------------
i) Setting up the PhpStorm IDE for xdebug to work properly
---------------
PhpStorm setup instructions. For our case, the instruction has been slightly modified.
 https://blog.denisbondar.com/post/phpstorm_docker_xdebug

 File - Settings -Build, Execution, Deployment" - Docker
 Check that the plus sign is pressed name = Docker, Connect to Doc.... = Unix socket
 Connection successful

 File - Settings - PHP
 We select our version of donut which is specified in Docker Compose
 To the right of the CLI Interpreter, click the button with three dots.
 In the CLI Interpreters window that opens, click the plus at the top left and select From Docker….
 Next you need to select Docker Compose
 Server = docker
 config file specifying our path to docker-compose.yml
select php-fpm in the service
 Next ok

 In the window that opens, set the name of our Docker Php 8.0, next to it, check the box visible only for this....
 Next checkbox Connect to existent container
 And we should have everything below, if not, then press ok and we can do the same (add)
 but set the php-cli option Always start a new container
 According to the idea that something should happen and it should display everything

 Path mappings is taken from docker-compose.yml (check the path in this window File - Settings - PHP )
 The folder on the local where our project is located vs the folder that is written in docker-compose.yml where our project is transferred

 File - Settings - PHP - Debug. And click on the Validate link.
  must specify the full path to the web root (in our example, this is the public subdirectory of the project)
 server address (in our example, port 80 of the nginx container, be sure to specify it http://127.0.0.1, or for example, http://127.0.0.1:8080). Click Validate.
 This check is configured everything is correct yes or no.

 File - Settings - PHP - Servers click the plus sign to add a new one.
 Specify the server name www (should match the PHP_IDE_CONFIG environment variable in docker-compose.yml) and host 127.0.0.1.
Write or check the mapping /var/www/app

 From the main Run menu go to Edit configurations…
 Click the plus sign at the top left and select PHP Web page. Specify a name for this page, for example, www,
 then specify the server this page is associated with (we created it in the previous step) and click OK.

Checking the work of xdebug
Now let's get to work.


-----------------------------------------
2) Template
-----------------------------------------
Now we need a template to put on our cms
But first, we need to think about the site, what will be there and how it will look.
We draw everything we want on a piece of paper, and then we refine it along the way.
Let's use Bootstrap

---------------
a) Main page
--------------
Everything is simple here, we divide the site into a template (what is unchanged, nav and footer) and a view (this is the middle, which will constantly change)
1) We take the standard from the Bootstrap website
2) we include font styles js
4) Create <header> here we will log in, then the main name of the project <h1> and navbar.
We take it from the standard Bootstrap template and update and tweak it a bit, bring it to ourselves.
5) We create the middle of the main site here we will have everything dynamically changing, since this is a blog here we will put up the type of one card
with transitions by topic. But first, let's put the title on top, what kind of <h2> section is this, then the blog itself (card).
Then jumps to the next page and climb quickly to the top.
6) Create <footer> everything is simple here, everything is standard.

---------------
b) Main page
--------------
We add a tab to add this, we will have a view, we tweak a little and change the previous page.
We add fields in the middle and our template is ready.
Further along the way, we will correct something, if necessary ....

-----------------------------------------
3) Creation of MVC and construction itself for the application
-----------------------------------------
We started and checked the performance of our environment, now we will write our core application !!!

---------------
a) Part one writing MVC core application creation "Initial files, creating a router"
--------------
We create a start class and from there we will write a router.
Since everything starts with public/index.php
there we write the standard code:
Error output
---
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);
---

Connecting an autoloader
---
require __DIR__ . '/../vendor/autoload.php';
---
In it we added 2 files
config/init.php --- Configuration file for easy coding (here we have constants with paths and some configuration) See the file itself for details.
helpers.php --- Additional functions that may be useful throughout the application. See the file itself for details.
These files are available everywhere because they are connected to our index, they are auxiliary.

Next we create a class new App(); in the src/Utils folder. In this file, all our classes will be run in turn, which
and will consist of our application.
In the constructor, we start the session and create a router class
---
public function __construct()
    {
        // Start session
        session_start();
        // Connect our router (router)
        $router = new Router();
        // Run the method
        $router->process();
    }
---
Create our Router in the src/Utils folder
The process() method will start our router from here. The principle is simple, we break our snare into a controller and a method.

We get PATH from the link, break the link to the array by elements. 0 key is empty, 1 is controller, 2 is action(method)
We form a full namespace of the class, if nothing came, then there will be a HomeController, if something came by force,
then we write the full path to this file, put the name in capital letters and add the word Controller
Next, we check whether this class exists with us, if not, we throw an exception.
Now it's up to the method. If nothing came by the snare, then we substitute the index. And if it came, then it means
Then we check whether this method exists in the class. And we throw all this into the getAction () method, which returns an array from
class and method.

In the process() method, we run the getAction() method and get an array of the class with the method we need to run.
Substitute and run.
We check for operability, while creating HomeController and TestController

---------------
b) Part two writing MVC core application creation "Module with bugs"
--------------
Create class ErrorHandler in src/Utils This class will be responsible for error handling on our application
In __construct() we write the logic for displaying errors if we do not display them in production. And if we display in development.
Next, we run the callback function set_exception_handler(); and in it we run our exceptionHandler method
and pass the error that came through the callback function.
Next, we run 2 methods in it:
logErrors() --- Creates a log file in the /tmp/errors.log folder and writes there in a nice way what errors happened.
displayError() --- It checks which mode we are in development or production. If in production, then in case of an error
redirects us to the 404 page /errors/404.template.php
If the development mode then beautifully shows the error in a beautiful form /errors/dev.template.php
Otherwise, if we are in production and this is not a 404 error, then it displays another page for the user with the error /errors/prod.template.php

To find out what mode we are in, the DEBUG constant is specified in the config/init.php file. She's true or false

---------------
c) Part of tritium writing MVC core creation application "Container Creation"
--------------
Create trait TSingletone - This trail will implement the Singletone pattern for us, it creates an object once.
Because we don't have to create more than one object of a given class. To do this, we create properties private,
these properties are filled with an object if it is not there. We write logic if our properties of the current class are empty null
then we will put an object of this class into it. And return this property back (there will always be this object class
which connected this trait)
We create our class Registry, connect trait TSingletone to it and create our container for properties
 protected static $properties = [];
We will put what is in the config/params.php file there and add additional parameters (properties) to this container
as needed.
We write 3 methods in class Registry:
setProperty() --- Add properties
getProperty() --- Get properties from there
etProperties()--- View all properties that are there
We will fill it in the config/params.php file as needed. Let's write this for testing:
---
return[
    'admin_email' => 'admin@gmail.com',
    'site_name' => 'Blog for preparing php interviews'
];
---
In class App we launch through this register
---
        // We connect our registry (we can store all our parameters in it)
        self::$app = Registry::instance();
        // Call getParams to populate the Registry::instance container with data
        $this->getParams();
---
and in the same place we create one more getParams() method to put the config/params.php parameters into the container, which we talked about
previously. From the beginning we connect them, then through the loop we add self::$app->setProperty($k,$v);


---------------
d) Part four writing the MVC core application "Working with Cache"
--------------
We need a cache so that our database and site performance are not so heavily loaded
We create a class Cache in the src/Utils folder and include the trait TSingletone so that it is created only once
And we create 3 methods to set the cache set(), get the cache get() and delete the cache delete()
- When creating cache set($key, array $data, int $seconds = 3600)
we set the key (this is the name of the file itself, we will first encrypt it with md5 )
then comes what we want to put there, it goes in an array, and for how long in seconds by default 3600sec = 1 hour
Put this file in tmp/cache folder
- When getting get(string $key) we look for this file, decode it and check if the date is not yet out of date, if it is out of date, then
the file is no longer valid. And return false. On exit, we make logic, an example in src/Controllers/TestController->cache()
- When deleting delete() just delete this cache if it exists.

See src/Controllers/TestController->cache() for an example of working with cache

---------------
e) Part five writing MVC core application "Base controller"
--------------
All other controllers come from the base controller, so it will be abstract for us.
We create an abstract class Controller in the src/Utils/Base folder. In it we write 4 properties that will accept data.
In the constructor, we will put parameters in the data properties so that we can use them in the frontend.
We create 3 properties:
- getView() --- launches the new View class and passes parameters there: template name, name of the folder where the view is stored and
weather data. Next, we run the method in View->show($this->data) passing there the data that needs to be passed to the frontend.
- setMeta() --- Create an array of weather data and put it in the properties.
- view() --- Pass the view folder name and data to class properties

---------------
f) Part six writing the MVC core application "Basic view"
--------------
This is the basic view that renders the page to the frontend and passes data there, everything is done through the controller.
We create a class View in the src/Utils/Base folder. In it we write 4 properties that will accept data.
In the constructor, we get this data from the base controller and pass it to the class properties.
We check the layout template and write logic through a ternary operator. If something came from the controller to $layout(true )
then we pass it, otherwise we pass what is in the constant.
We write 2 methods:
- show($data) --- This method is run from the controller. Its main task is to render the page and send data to the frontend.
It accepts the date that was passed from the controller to the array. In it, we translate everything into a variable (key = name of the variable).
Further, we divide into work with the view (template) and work with the template (layout).
View(template)--- Check if something came in template and we are in developer mode? If nothing has passed and the regime
DEBUG, it means that we include a template in the view that there is no such page. Otherwise, we throw the name of the species. And if the conditions are not met
type production mode, then we throw out an error.
Next, we form the path for the video and check if there is such a file with the same name. Enable buffering and send to
frontend, if something is wrong, we throw out an error.
Template(layout)--- Check something came, form the path to the template. Check if there is such a file, if not, throw it away
error. We connect it. If something is wrong, then throw an error
- getMeta() --- generate html code for meta and substitute what came in there. Returning to the page

---------------
g) Part seven writing the MVC core application "daddy view"
--------------
Working with our pages (view/template)
folder and file structure
view -> errors (there are templates with errors)
.... -> layouts (our templates, what doesn't change/themes change type to night/day view)
.... -> main (the main page of the view (the one in the middle) and subsequent folders, this will be our view)
.... -> giglet_main.template.php (stub)
Everything is simple here in our template in the layouts folder, just substitute the data and cut out the middle (view) what will be dynamic
part of the site they will be located in folders

---------------
h) Part eight writing the MVC core application "Base Model"
--------------
Needed to work with business logic and our database
First we need to connect to our database, since we use the RedBeanPHP library
Using the composer, install the RedBeanPHP library
Next, create a class Db in the src / Utils folder, connect use trait TSingletone to it
And in the constructor we connect our configuration file (config_db.php) for the database in it
---
return[
    'dsn' => 'mysql:host=172.25.0.6;dbname=app;charset=utf8',
    'user' => 'root',
    'pass' => 'test',
];
---
Next, we connect to the database, substituting the data, checking whether it is connected or not, writing to the log.
Most of the RedBeanPHP functions are not needed in production, so we write further in the logic a check if in production
It freezes unnecessary functions.

Then we create an abstract class Model in the src/Utils/Base folder.
We make it abstract in the constructor, we connect our class Db.

---------------
i) Creating our blog......
--------------
Our kernel is created, now we create:
1) controllers
2) cover
3) model
4) we make sure that everything works and begin to refine the system ...

---------------
i.1)  Controller
--------------
Since we scored the beginning on HomeController extends Controller, we will start with it. Each controller must have a mandatory
completed record.
---
      // meta data
      $this->setMeta(
          'title',
          'desc',
          'keywords'
      );
      // connects the template and passing data to the view
      $this-> view('main.main', $data);
---

We make one more controller for testing the entire cms and functionality class TestController extends Controller
We test and test, see the controller itself

---------------
i.2) layouts/view
--------------
When we have a controller and we checked the functionality for operability, we connect the appearance of the site
In the layouts folder we have 2 files. If we need to change the theme/design (light/dark) of our template. For check
just change the background to dark
Now we put the middle, in the main folder it will be the main page, in the add folder it will add an entry to the database
We split the code and add it to the file. For errors, we create the middle (view) giglet_main.template.php there we will print
command console in db.
We test everything for performance with the help of the TestController controller.

---------------
i.3) Model
--------------
Now we will work with our database
Create 2 models class Blog extends Model --- for our cms and class Test extends Model --- for the redbeanphp test
Testing the functionality / features of redbeanphp


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
i.4) Continued work / main development of our application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Making sure everything works think about how everything will look like (business logic) --- constantly rewriting the code ---
We divide tasks into modules (functionality) and add it gradually to our project. When we were convinced that this implementation
suitable, after that we wrote down this implementation in the abstract.
---------------
Subtask Breakdown Plan
--------------
1) Adding an entry to the database
    a) Creating a Controller
    b) Checking data comes and than "start() method"
    c) Passing validated data to the model "Method add"
    d) Data validation "Method validation"
    e) Transition to model (db) Creation of tables
2) Displaying information on the site page
    a) Getting from the database - the load method
    b) view output
    c) Subject tag or page selection
    d) General controller "TypeController"
    e) HomeController
    f) PracticeController
3) Registration, login, modal window. Working with js
    a) Adding a modal window to the "light_blog.template.php" template
    b) Writing a js/jquery script to register or login "main.js"
    c) Connecting templates for registration and login "ModalController"
    d) Templates for registration and login
    e) Working with the user (registration, login, validation, session) "SignController"
    f) Working with the user in the database "Blog"
4) Editing / deleting a post, editing session templates
    a) Editing .template.php templates
    b) Creating an "EditController" controller
    c) Adding edit, remove and findPost method to 'class Blog extends Model'

---------------
i.4.1.a) Adding an entry to the "Create controller" database
--------------
Create a controller class AddController extends Controller in the src/Controller folder
To load data so that you can work with them and understand how the system will generally work, so to speak, the architecture
In the constructor, we add a new model class new Blog () to the properties so that we can work with the database.
Since all methods in our router start with index(), this is our start method.
Since one method can launch a page and add data to the database, we check which request came
If get, then we ask the rendering of the page. If by post, then we get the data, validate it, send it to the model
and we get the answer ok or not ok and based on this we write a message how everything went.

---------------
i.4.1.b) Adding an entry to the database "method start()"
--------------
When we received the data by post, we run the start () method
We check that which button was pressed $_POST['send'] or $_POST['dell'] and something should come, then check for emptiness
If there is nothing in the array, then we return an empty string. We call the corresponding method and pass this data there.
If the check fails, we throw out the exception.
On the button $_POST['dell'] we make the method dell($type, $postId); and in the method itself a dummy, to check the performance.

---------------
i.4.1.c) Adding an entry to the database "Method add"
--------------
The add method creates or updates a table. To begin with, we will implement the creation of tables ....
Immediately in it, we validate the data that came to us in the validation method
Then it came from the validation method, we throw everything into the Blog () model, the create method and pass the validated data there

---------------
i.4.1.d) Adding an entry to the database "validation method"
--------------
The validation method here is data validation.

---------------
i.4.1.e) Adding an entry to the database or passing to the model (db) Creating tables "Method create"
--------------
Now go to the file in the folder src/Model/class Blog extends Model
We create the create method, we will use the many to many method in Redbean. Create a table and substitute data, return table id
Note in the documentation, may return a string.
Since we repeat the tag, we use findOrCreate.

---------------
i.4.2) Displaying information on the site page
--------------
We filled in the data in the table, now we display this data in the section in "Theory" and "Practice"
Output data to the page. We will display on the topics of a certain section. Topics is the id number of the tags. And it will
we have a page. Let's make the main controller, let's call it TypeController, everything will be common here and it will go from it to
HomeController and PracticeController. Then everything is passed to the template/view.

---------------
i.4.2.a) Displaying information on the site page "Getting from the database - load method"
--------------
In the HomeController, we pull our Blog model with the load($themes, $index) method, where $themes is the name of the column (theory/practice)
and $index is the id of the tag we'll be loading the theme. The default will be 1.
In class Blog extends Model which is in src/Model. We create the load method. In it, we first create a dynamic
property name. Further loading the list of tags which is in a DB. Loop through this list (array) through foreach,
forming a new array that consists of id and reformatting it into a regular array (we remove beams).
Next, we check that there is such a number that we received with the array id. If not, then $index = 1.
Further, the selected property bean has a check, we get true or false. If not, then this tag does not belong to this section.
After all the checks, we go through the array (bin) in a loop and create a new array of data that must be transferred to the view,
after converting it to a regular array.
Add to this array what tag is selected. We return everything.

---------------
i.4.2.b) Displaying information on the site page "Output to view"
--------------
In the HomeController, what we got is displayed in the view in main.template.php. With the help of a loop, we substitute the data and test.

---------------
i.4.2.c) Displaying information on the site page "Tag subject or page selection"
--------------
Since in the tags table there are topics in the theory and practice table, you need to sort them and this will be our selection page at the bottom
To do this, in the Blog model, the tag method, we first check what kind of topic the page will pass to us. And from this topic we will load the intermediate
table. If it doesn't exist, we'll throw an error.
We load this intermediate table id, remove the duplicate elements and set the array keys to zero. With the help of a loop, we bring this array
into a beautiful view. And send it back to the controller. There we put it in the $data['page'] array and pass it to the view.
In the view (main.template.php) where the page selection is using a loop, we substitute, where the key is the page number, and the value
will be a get parameter.
And it turns out by clicking on the page number we will pull the id that will come through the get parameter of the given topic!

---------------
i.4.2.d) Displaying information on the site page "General Controller - TypeController"
--------------
Since the code will be the same, in HomeController and PracticeController we will create a TypeController
And put the general code there
In the constructor, add the model $this->nameModal = new Blog();
In the dbData method, we will work with the model and call the tag and load methods in the model. We put all this beautifully into an array and return it.
In the getReqParam method checks the Get parameter

---------------
i.4.2.e) Displaying information on the "HomeController" site page
--------------
class HomeController extends TypeController this is our main page of the controller, here we will have the conclusion of the theory.
We will call the getReqParam method on the TypeController. This method checks for something to come in the get parameter.
If it is empty, it will return the array key that is needed to load the given theme page.
Next, we form the $data array, first we pass the page description there, then using the array_merge function,
we join the array. Which were received when calling the dbData method in the TypeController with the $data array
and pass everything to the view. Testem, everything works ...

---------------
i.4.2.f) Displaying information on the "PracticeController" site page
--------------
Everything is the same as in HomeController, only we change the theme of the page / table name to practice and substitute the data
for practice.

---------------
i.4.3) Registration, login, modal window. Working with js
--------------
In this chapter I will add registration, login and session. Adding a new user to the database.
First, I add a modal window to the main template, connect it, using jqury I make buttons, when I click on
a certain button is a request for ajax file. And the controller is loaded, which connects the forms (registration or login)
dalia when filling in data and sending via jquery. The data is validated and sent to the server to the controller
via post.
The controller takes it all, validates the data and sends it to the model. The model creates a user table, adds it or
checks if there is such a user, then writes to the session that there is such a user and change the inscription in the template that the user is logged in,
if you click on this inscription again, the session is deleted

---------------
i.4.3.a) Adding a modal window to the "light_blog.template.php" template
--------------
ЗWe go to the bootstrap site and take the shape of the modal window from there. Insert it at the very bottom of our template
 view->layouts->light_blog.template.php override js strip
 We correct it a little and add additional classes.
 We connect it by the link where we should have registration. With the help of bootstrap classes
 <a href="" class="login" data-bs-toggle="modal" data-bs-target="#staticBackdrop">Sign in/up</a>

 ---------------
 i.4.3.b) Writing a js/jquery script to register or login "main.js"
 --------------
 Create main.js file in public->js folder
  - We write in the function when everything is loaded, we issue the theme, text and buttons of the modal window. First thing to see
 user.
  - We create an ajax function, it accepts a url for the controller (which one will be launched). Get request goes if everything is ok
 (controller is started) let's go to the response, in our case it will be the response of the html form for the body of the modal window.
  - Registration function
 When you click on the register button, the name of the window theme changes and a request is made via ajax (a function called ajax) with
 given url 'modal/signUp' ( see point i.4.3.c) we get the registration form. Next we display the submit button.
 When you click on the submit button, we get the field data.
 Next, we go through the validation of this data:
     - Email verification. If the validateEmail function is true, then we hide the error if it was there, and write down what
       turned into the emailCheck variable. Otherwise, we highlight an error under the water field. function validateEmail(email) -
       accepts email, searches for a match of all characters in the string that was given.
     - Password verification. If the validatePass(pass) function is true, then we hide the error if it was there and write
       what happened to the passOk variable. Otherwise, we highlight an error under the water field. validatePass(pass) function -
       will give true only when the password length is from 5 - 12 characters
     - Checking repeated password. Password fields 1 and 2 must match, then we passCheck = passOk; write down the password
       and hide the error. Otherwise, we highlight an error under the water field.
     - Checking if the data has been entered correctly. If emailCheck and passCheck have something in them, then we run the function
        SignInUp('Sign/signUp', emailCheck, passCheck); sending this data.
  - Login function
  When you click on the login button, the name of the window theme changes and a request is made via ajax (a function called ajax) with
  given url 'modal/signIn' ( see point i.4.3.c) we get the login form. Next we display the submit button.
  When you click on the submit button, we get the field data.
  Next, we go through the validation of this data:
      - Email verification. If the validateEmail function is true, then we hide the error if it was there, and write down what
        turned into the emailCheck variable. Otherwise, we highlight an error under the water field. function validateEmail(email) -
        accepts email, searches for a match of all characters in the string that was given.
      - Password verification. If the validatePass(pass) function is true, then we hide the error if it was there and write
        what happened to the passCheck variable. Otherwise, we highlight an error under the water field. validatePass(pass) function -
        will give true only when the password length is from 5 - 12 characters
      - Checking if the data has been entered correctly. If emailCheck and passCheck have something in them, then we run the function
         SignInUp('Sign/signUp', emailCheck, passCheck); sending this data.

  - Function SignInUp(url, email, pass) - accepts a url to register or enter the email controller and a password. She sends
  ajax data request (email and password) through the post, if everything went well, we receive data from the controller in the body of the modal window
  - When you click on the close button, the page will reload

---------------
i.4.3.c) Connecting templates for registration and login "ModalController"
--------------
Create class ModalController extends Controller in src/Controller folder. Its action is that
Returns/includes a template, registration or login.
- the signUp method connects the registration template 'view/login/login/sign_up.template.php'
- the signIn method connects the login template 'view/login/login/sign_up.template.php'

---------------
i.4.3.d) Registration and login templates
--------------
Create 2 php files sign_up.template.php and sign_up.template.php in the view/login/login/ folder. In it we copy from bootstrap
field templates for registration and the same field, the current is slightly changed for the entrance. Slightly changing the template, add a class
to output errors class="error-pass" for js. Difference between registration and login, one field in registration for re-entry
password verification.

---------------
i.4.3.e) Working with the user (registration, login, validation, session) "SignController"
--------------
We create a class SignController extends Controller, it will contain the logic of working with users. Entering
user or checking the user in the database, data validation, session work, etc. All that is user accreditation.
In the constructor, we connect our database.
- signIn() method to sign in. The data that we will receive through ajax - post. We immediately transfer them to the method
validation($_POST) (see below). Next, we check for errors, if there were errors in the validation, if they did, then
write to the log file and issue a message that there is an error in the login or password. If everything is ok, then we check if such
email using the emailCheck method in the Blog modal (see i.4.3.f). If the response is null, then there is no such email
exists, write it to the log and throw out an error that such a user does not exist. And to the user in the modal window
we conclude that he needs to register.
If the user array has arrived, then we check the password for compliance (compare). If an error, then highlight and write to the log
If everything is ok, then we write down the username, in our case, his email in the session.
- method signUp() registration of a new user. The data that we will receive through ajax - post. We immediately transfer them to the method
validation($_POST) (see below). Next, we check for errors, if there were errors in the validation, if they did, then
we go through them in a loop (we collect them in one line) and display on the screen where the user made a mistake. If everything is ok
then we check if there is such an email using the emailCheck method in the Blog modal (see i.4.3.f). If the response is null,
it means that there is no such user and we can encrypt his password. And transfer this data to the createUser method in the modal
Blog (see i.4.3.f), for creating a new user. In return, we will get its id. Next, check if id is 0, then
something went wrong and the user did not register. Issuing relevant messages
- the validation() method is used for data validation. We check that the data that came is something, if not, then
return an empty string. The email must match the format and must come, the password must be more than 5 characters and
less than 12, the same should be. If there are any errors, then return them, if not, then return the array with the email and password
- method logOut() this method simply deletes the session with the username and reloads the page.
---------------
i.4.3.f) Working with the user in the database "Blog"
--------------
In our modal src/Model/class Blog extends Model, we add 2 methods createUser, emailCheck
- createUser method create a user table with id, email, password fields and save all this by returning the user id.
- the emailCheck method, we are looking for the user's email, if it is not there, then return null, if there is, then an array of data.

---------------
i.4.4) Editing / deleting a post, editing session templates
--------------
Since we already have registration, and since the current registered user can edit or delete the post.
We can start editing and adding to the post
In this chapter, we will create an EditController and add search, edit, and delete posts to our Blog modal.
We will also edit the templates and css a little.
---------------
i.4.4.a) Editing .template.php templates
--------------
Since we have an input / logging, we brought it all into the session. And we can show the current those possibilities that
allowed for admins.
Editing files in the view folder
- layouts/light_blog.template.php Where the login is, we write the logic if $_SESSION['isLogin'] is something, then we display the email
and exit button. Where there is an add button in the menu, we write logic, if there is $_SESSION['isLogin'] then we display the add link.
- main/main.template.php There's an edit button next to each post. We write logic if there is $_SESSION['isLogin'],
means we deduce a link and we form it. Create a dynamic get parameter with post id, subject and type.
- add/add.template.php is a bit trickier here, since one template works on 2 fronts. In the controller (see below) added
parameter $siteData['link'] if == 'edit' then this is for editing, if == 'add' then for adding. From there we will
proceed. We write logic on the forms, if we have 'edit' selected, then the forms are blocked and we insert the text that we have chosen in them
for editing. Otherwise, we write it for addition manually (new post). We also change in css properties what these
the shapes are locked and change the color of them for beauty. Well, we work with buttons if 'edit' is selected, then the button is below
editing and deletion. Otherwise, the submit button.

---------------
i.4.4.b) Creating an "EditController" controller
--------------
In this controller, the logic for editing and deleting a post will occur.
Create a controller in the src/Controller/class folder EditController extends AddController
It is checked by which method $_SERVER['REQUEST_METHOD'] == 'GET' came, then what has come for data validation is thrown.
Since we extends AddController we can use the methods of AddController and move on to validation...
In the AddController method, we tweaked the validation method a bit, since index and comment are not received in the geta.
After the validation has passed, we look for this post in our database, if we find it, we transfer it to the template. (see above)
If an error occurs at any stage of the check, we act accordingly.
When the text is edited, it again goes to check by which method it came, in our case it is already POST.
We run the start() method in AddController , this method checks which button was pressed and runs the corresponding method
- The edit method first, we run the received data through the validation method, then we run the edit method in our Blog modal (db)
- The dell method also goes through the data itself through validation and then passes it to our database using the remove method in our modal Blog
In both cases, we get id. In EditController we check if the number means ok, if not, then not ok. and output the corresponding
message. Next, we display the required data for displaying the page setMeta and view
- The findPost method searches for a post, or rather it runs the findPost method in our Blog modal and returns an array or null

---------------
i.4.4.c) Adding edit, remove and findPost method in 'class Blog extends Model'
-------------
In our modal src/Model/class Blog extends Model, we add 3 methods edit, remove and findPost
- method edit post editing. Loads the paste and makes a change to it
- method remove post removal. First finds the post id tag, then generates a dynamic table name and deletes
connections and the record itself in the database
- the findPost method finds this post. First, we find the post tag, then we form a dynamic string for the table name and load
this post is from db.
---------------------------------------
