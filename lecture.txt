~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|...............................................................................................|
|------------------- Инструкция / алгоритм как я создал свой cms на базе mvc -------------------|
|...............................................................................................|
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---------------------------------------- Содержание ---------------------------------------------

1) Настройка окружение "Docker - Compose"
2) Шаблон
3) Создание MVC и само построение на приложение

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

----------------------------------------- Основа -----------------------------------------------

-----------------------------------------
1) Настройка окружение "Docker - Compose"
-----------------------------------------
Определяемся что нам надо для нашего cms. А это сервер, возмем nginx. Сам язык интерпретатора php-fpm, и mysql.
Вообшем ставим что то подобное LEMP
https://maddot.ru/kak-ustanovit-lemp-v-ubuntu-20-04.html
Дальше нам нужен git и composer......

---------------
a) docker-compose.yml
---------------
Создаем файл с названием docker-compose.yml и в нем пишем
# так обозначаются комментарии
# С начало ставим версию докер композера
version: '3.7'

# Тут дальше идет какие мы сервисы хотим запустить.Так назваемая инструкция
# Название сервисов может быть любыми, но что бы было логически понятно какие там инструкции будут php: или mysql:
services:
# Ставим сервер
  nginx:
    build:
    # Указываем путь, где находятся настройки(правела установки) сервера
      context: ./docker/nginx
    volumes:
    # Прописываем путь к нашему проекту и контейнера, где ./ это является путь обращение этой папки на компе.
    # Двоеточие означает "к"  наш комп : виртуалка
      - ./:/var/www/app
    ports:
    # Прописываются порты. Что бы был такой адрес https://locallhost/ надо использовать 80 порт
      - "80:80"

# Дальше у нас идет интерпретатора языка
    php-fpm:
        build:
         # Указываем путь, где находятся настройки(правела установки) интерпретатора языка php
          context: ./docker/php-fpm
        volumes:
        # Прописываем путь к нашему проекту и контейнера, где ./ это является путь обращение этой папки на компе.
        # Двоеточие означает "к"  наш комп : виртуалка
          - ./:/var/www/app
        environment:
        # настройка XDEBUG для убунту/ phpstorm. Путь прописан к обращению .env файлу
          PHP_IDE_CONFIG: serverName=${SERVER_NAME}
        env_file:
        # путь для .env там находятся настройки/пароли/и т.д. нашего окружение. Эта строка работает для всего
          - .env
        networks:
          default:
          # Указываем ip для взаимодействия приложений между собой
            ipv4_address: ${PHP_FPM_IP}

# Далее идет у нас База данных mysql
    mysql:
    # Берем готовую сборку с https://hub.docker.com/
        image: mysql:8.0
        environment:
        # Задаем имя DATABASE и рутовский пароль. Он хранится в .env файле
          MYSQL_DATABASE: ${DB_NAME}
          MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
          # Задавать настройку, подробности тут
          # https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password-root-account
        command: --default-authentication-plugin=mysql_native_password
        volumes:
        # БД будет хранится в докере
          - mysql_data:/var/lib/mysql
          # копирование команд бд в папку вируализации (типа минималка которая должна быть на виртуализации таблица и заполнение ее)
          - ./init.sql:/docker-entrypoint-initdb.d/init.sql
        ports:
        # В каких портах работает 1 к 1
          - "3306:3306"
        networks:
          default:
          # ip адрес для взаимодействия между программ. Он хранится в .env файле
            ipv4_address: ${MYSQL_IP}

# Далее идет правела по взаимодейсвию между программ
    networks:
      default:
      #  по системе bridge совершается конекшон
        driver: bridge
        ipam:
          config:
          # нетворк между контенерами
            - subnet: ${NETWORK_SUBNET}
    volumes:
    # бд хранится в докере
      mysql_data:

---------------
b) Настройка nginx в docker/nginx
---------------
---
В Dockerfile пишем это
---
    # Задаем архетиктура из докерхаба https://hub.docker.com/
FROM nginx:1.21-alpine
    # указываем настройки копируются с- в
COPY ./conf.d /etc/nginx/conf.d
    # Указываем рабочию дерекцию в виртуалке
WORKDIR /var/www/app

---
Далее настройки нашего сервера они находятся в папке docker/nginx/conf.d/
Создаем фаил default.conf и пишем это
---
# Этот блок означает что мы будем обслуживать какой-то хост
server {
# слушаем порт постоянно. (рабочий порт)
    listen 80;
# Какие файлы считать по дефолту начальными что открыть
    index index1.php index.html;
# Наш адрес url
    server_name 127.0.0.1 localhost;
# С какой папкой работать. Где старт/ точка входа /Путь где будет искать index...
    root /var/www/app/public;

# Все запросы будут делатся только на index.php (обработка / )
    location / {
# Проверяет если не index.php то перенаправляет на index.php
        try_files $uri /index.php?$args;
    }

# Так как у нас нет в nginx php то благодоря композеру указываем путь на него (Обработка php )
    location ~ \.php$ {
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php-fpm:9000;
        fastcgi_index index1.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    error_log /var/log/nginx/project_error.log;
    access_log /var/log/nginx/project_access.log;
}


---------------
c) Настройка интерпретатора языка php в docker/php-fpm
---------------
---
В Dockerfile пишем это
---
# Задаем архетиктура из докерхаба https://hub.docker.com/
FROM php:7.4-fpm-alpine

# Запускаем команды для дополнительной установки доп. программ (все то же самое что писать в командной строке в линуксе)
RUN apk update && apk add unzip autoconf g++ make \
    && pecl install xdebug \
    && docker-php-ext-install pdo_mysql && docker-php-ext-enable xdebug

# переименовываем фаил
RUN mv $PHP_INI_DIR/php.ini-development $PHP_INI_DIR/php.ini

# копируем с нашей папке в виртуалку настройки
COPY ./conf.d /usr/local/etc/php/conf.d
COPY www.conf /usr/local/etc/php-fpm.d/

# даем рутовские права (что бы было возможно создавать и удалять)
USER 1000:1000

# Рабочая директория
WORKDIR /var/www/app

---
Создаем фаил www.conf это конфигурационный файл для нашего php
---
[www]
user = www-data
group = www-data
clear_env = no
listen = 9000
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3

---
Создаем файл xdebug.ini в папке docker/php-fpm/conf.d
---
[xdebug]

xdebug.start_with_request = yes
xdebug.discover_client_host = 1
# Для хоршого отображение
xdebug.mode= debug, develop
# порт стандарт 9003
xdebug.client_port= 9003
#  172.17.0.1 хост для удаленной отладки ifconfig ишем раздел docker0:
xdebug.client_host= 172.17.0.1
# что бы подсветка была красивая
integer xdebug.cli_color = 1
# Принцепи это есть в env файл но решил еше сюда добавить
xdebug.idekey= PHPSTORM


---------------
d) Файл .env
---------------
В файле .env  тут у нас хранятся настройки/ пароли именно для нашей рабочей среды. При необходимости мы можем его легко изменить

# Настройки MySQL для входа
DB_PASSWORD=test
DB_NAME=app

# нетворк между контенерами
NETWORK_SUBNET=172.25.0.0/24
PHP_FPM_IP=172.25.0.3
MYSQL_IP=172.25.0.6

# настройки XDEBUG для убунту/ phpstorm
SERVER_NAME=www

Создаем фаил .env-example для гита, там будет пример настроек

---------------
d) Файл init.sql
--------------
---
Создаем файл init.sql для нашей бд что бы создалось первоначальные база данных для работы с нашем приложение
---

CREATE USER 'admin'@'172.25.0.6' IDENTIFIED BY 'test';
GRANT ALL ON *.* TO 'admin'@'172.25.0.6';
FLUSH PRIVILEGES;
# Если нажна таблица вот пример как ее создать в коментарии
# CREATE TABLE test (
#                          id int auto_increment primary key,                           col1 datatype,
#                         tile varchar(255) not null
# );
# INSERT INTO test(tile)
#      VALUES
#       ('text1'), ('text2');

---------------
e) Файл .gitignore
--------------
---
Ну тут все просто. Файлы которые недолжны попасть в гитхаб
---
.idea/
.env
vendor/

---------------
f) Файл composer.json
--------------
{
  "authors": [
    {
      "name": "Pasha Karpunin",
      "email": "amedomaro2@gmail.com"
    }
  ],

  "autoload": {
    "psr-4": {
      "App\\": "src/"
    },
    "files": ["helpers.php", "config/init.php"]
  },

  "require": {
    "gabordemooij/redbean": "dev-master"
  }
}

---------------
g) Структура папок проекта
--------------
src -> Controllers
.... -> Models
.... -> Utils
tmp-> cache
view -> errors
.... -> layouts
.... -> main
vendor - (автоматически появится)
public -> pic
  .... -> css
  .... -> js
config

Это первоначальная струкрура папок, далее мы будем добовлять по мере необходимости
---------------
h) Запуск "Docker - Compose"
--------------
Для запуска сначала билдем что бы создать образ
#       docker-compose build

Это делается один раз что бы создать образ, можно конечно сразу его запустить с помошю команды docker-compose up --build
Но иногда происходит артефакты. Поэтому просто сначало билд. Потом запуск
#       docker-compose up

Для проверки в файле index.php вставляем этот код
---

// phpinfo();

//ini_set('xdebug.var_display_max_children', 3 );
//$c = new stdClass;
//$c->foo = 'bar';
//$c->file = fopen( '/etc/passwd', 'r' );
//var_dump(
//    array(
//        array(TRUE, 2, 3.14, 'foo'),
//        'object' => $c
//    )
//);

---
Проверяем что все работает, все ок !!!
Теперь устанавливаем composer, что бы все зависимости и автолоудер у нас работал
#       composer install

Появляется папочка vendor, значит все ок, все установилась.
Что бы обновить свои данные там, даме команду
#       composer dumpautoload

Когда все закончили работу, останавливаем докер.
#       docker-compose down

---------------
i) Настройка IDE PhpStorm для адекватного работы xdebug
---------------
Инструкция настройки PhpStorm. Для нашего случая инструкция немного изменена
 https://blog.denisbondar.com/post/phpstorm_docker_xdebug

 File — Settings -Build, Execution, Deployment» — Docker
 Проверяем что бы был нажат плюсик name = Docker, Connect to Doc.... = Unix socket
 Connection successful

 File — Settings - PHP
 Выбираем нашу версию пышки которая указана в Docker Compose
 Справа от CLI Interpreter нажмите кнопку с тремя точками.
 В открывшемся окне CLI Interpreters нажмите плюс слева вверху и выберите там From Docker….
 Далее нужно выбрать Docker Compose
 Сервер = докер
 конфигурационный файл указав наш путь к docker-compose.yml
в сервисе выберем php-fpm
 Далее ок

 В открывшимся окне задаем имя нашего Docker Php 8.0, рядом ставим галочку visible only for this....
 Далее галочка в Connect to existent container
 И у нас внизу должно быть все указано если нет то нажимает ок и можем проделать все то же самое (добавить)
 но ставим php-cli опцию Always start a new container
 По идеи, что то должно произойти и оно должно все отобразить

 Path mappings берется из docker-compose.yml (проверяем путь в этом окне File — Settings - PHP )
 Папка на локальном где лежит наш проэкт vs папка которая записано в docker-compose.yml куда перекидывает наш проэкт

 File — Settings - PHP - Debug. И нажмите на ссылку Validate.
  должны указать полный путь к web-корню (в нашем примере это подкаталог проекта public)
 адрес сервера (в нашем примере порт 80 контейнера nginx укажите обязательно его http://127.0.0.1,или например, http://127.0.0.1:8080). Нажмите Validate.
 Это проверка настроено все верно да или нет.

 File — Settings - PHP - Servers нажмите плюсик, чтобы добавить новый.
 Укажите имя сервера www (должно совпадать с переменной окружения PHP_IDE_CONFIG в docker-compose.yml) и хост 127.0.0.1.
Пропишете или проверти мапинг  /var/www/app

 В главном меню Run перейдите в Edit configurations…
 Нажмите плюсик вверху слева и выбирайте PHP Web page. Укажите имя для данной страницы, например, WWW,
 затем укажите сервер, с которым связана эта страница (мы создали его на предыдущем шаге) и нажмите OK.

Проверяем работу xdebug
Теперь приступаем к работе.


-----------------------------------------
2) Шаблон
-----------------------------------------
Теперь нам нужен шаблон, что бы на него одеть нашу cms
Но для начало нам надо продумать сайт что там будет и как он будет выглядеть.
На листочке бумаге рисуем все что хотим, а дальше по ходу дорабатываем.
Будем использовать Bootstrap

---------------
a) Главная страница
--------------
Тут все просто, делим сайт на шаблон (то что неизменно, нав и футер) и вид (это середина, которая будет постоянно меняться)
1) Берем стандарт с сайта Bootstrap
2) подключаем шрифт стили js
4) Создаем <header> тут будет у нас логиниться, потом главное название проекта <h1> и navbar.
Его берем из стандартного шаблона Bootstrap и немного обновляем и подправляем, подводим до себя.
5) Создаем середину сайта main тут у нас будет все динамически меняться, так как это блог сюда выставим типа одной карточки
с переходами по темам. Но для начало поместим сверху название, что это за раздел  <h2> потом сам блог(карточку).
Затем переходы на следующею страницу и подняться быстро на верх.
6) Создаем <footer> тут все просто, все стандартно.

---------------
b) Главная страница
--------------
Добовляем вкладку добавить это у нас будет видом, немного подправляем и изменяем предыдущею страницу.
В середину добавляем поля и все наш шаблонщик готов.
Дальше по ходу, что-то подправим, если будет надо....

-----------------------------------------
3) Создание MVC и само построение на приложение
-----------------------------------------
Мы запостили и проверяли работоспособность нашего окружение, теперь будем писать наше ядро приложение !!!

---------------
а) Часть первая написание MVC создания ядра приложение "Начальные файлы, создание роутер"
--------------
Создаем стартовый класс и от туда будем писать роутер.
Так как все стартует с public/index.php
там пишем стандартный код:
Вывод ошибок
---
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);
---

Подключение автолоудера
---
require __DIR__ . '/../vendor/autoload.php';
---
В нем мы добавили 2 файла
config/init.php      ---   Фаил конфигурации для легкого кодирование (тут у нас константы с путями и немного конфигурации) См сам файл, за подробностями.
helpers.php          ---   Дополнительные функции которые могут пригодиться для всего приложение. См сам файл, за подробностями.
Эти файлы доступны везде так как они подключены к нашему индексу, они вспомогательные.

Дальше создаем класс new App(); в папке src/Utils . В этом файле будут поочередно запускаться все наши классы которые
и будет состоять наше приложение.
В конструкторе стартуем сессию, и создаем класс роутера
---
public function __construct()
    {
        // Стартуем сессию
        session_start();
        // Подключаем наш роутер (маршрутизатор)
        $router = new Router();
        // Запускаем метод
        $router->process();
    }
---
Создаем наш Router в папке src/Utils
Метод process() отсюда будет стартовать наш роутер. Принцип прост, разбиваем нашу сылку на контролер и метод.

Получаем PATH от ссылки, разбиваем ссылку на массив по элементам. 0 ключ - это пустота, 1 - контролер, 2 - экшон(метод)
Формируем полный неймспейс класса, если нечего не пришло, то тогда будет HomeController, если что-то пришло по сылке,
значит прописываем полный путь к этому файлу, название ставим заглавной буквы и добавляем слово Controller
Далее проверяем существует ли этот класс у нас, если нет кидаем эксепшон.
Теперь дело за методом. Если нечего по сылке не пришло, значит подставляем метод index. А если пришло, то значит его
Потом проверяем есть ли в классе этот метод. И все это закидываем в метод getAction(), который возвращает массив из
класса и метода.

В методе process() мы запускаем метод getAction() и получаем массив класса с методом, что нам надо запустить.
Подставляем и запускаем.
Проверяем на работоспособность, создав при этом HomeController и TestController

---------------
b) Часть вторая написание MVC создания ядра приложение "Модуль с ошибками"
--------------
Создаем class ErrorHandler в src/Utils Этот класс будет отвечать за обработку ошибок на нашем приложении
В  __construct() пишем логику отображении ошибок, если мы в продакшене их не отображаем. А если в разработке отображаем.
Далее запускаем callback функцию set_exception_handler(); и в нем мы запускаем наш метод exceptionHandler
и передаем через callback функцию ошибка которая пришла.
Далее запускаем в ней 2 метода:
logErrors() --- Создает лог файл в папке /tmp/errors.log и туда помешает в красивой форме какие ошибки произошли.
displayError() --- Он проверяем в каком режиме мы в разработке или продакшоне. Если в продакшене, то в случае ошибки
перекидывает нас на страничку 404 /errors/404.template.php
Если режиме разработки то красиво показывает ошибку в красивой форме /errors/dev.template.php
Иначе если мы в продакшене и это не 404 ошибка то выводит для пользователя другую страницу с ошибки /errors/prod.template.php

Что бы узнать в каком мы режиме в файле config/init.php указана константа DEBUG. Она в true или false

---------------
c) Часть трития написание MVC создания ядра приложение "Создание контейнера"
--------------
Создаем trait TSingletone - Этот трейл будет реализовывать нам патерн Singletone, создает один раз объект.
Так как мы недолжные создать более чем одного объекта данного класса. Для этого мы создаем свойства приватное,
это свойства заполняем объектом, если его там нет. Пишем логику если у нас свойства текущего класса пуста null
то тогда мы в него положим объект данного класса. И вернем это свойство обратно (там всегда будет этот класс обЪекта
который подключен этот trait)
Создаем наш class Registry к нему подключаем trait TSingletone и создаем наш контейнер для свойств
 protected static $properties = [];
Мы будем туда засовывать то что есть в файле config/params.php и добавлять дополнительные параметры(свойства) в этот контейнер
по мере надобности.
В class Registry пишем 3 метода:
setProperty() --- Добавить свойства
getProperty() --- Получить от туда свойства
etProperties()--- Просмотреть все свойства, что там есть
В файле config/params.php по мере необходимости будем его заполнять. Для теста напишем это:
---
return [
    'admin_email' => 'admin@gmail.com',
    'site_name' => 'Блог для подготовки php собеседований'
];
---
В class App запускаем через этот регистр
---
        // Подключаем наш реестр (в нем мы можем хранить все наши параметры)
        self::$app = Registry::instance();
        // Вызываем getParams что бы заполнить контейнер Registry::instance данными
        $this->getParams();
---
и там же создаем еше один метод getParams() что бы засунуть параметры config/params.php в контейнер, о чем мы говорили
ранее. С начало подключаем их потом через цикл добавляем self::$app->setProperty($k,$v);


---------------
d) Часть четвертая написание MVC создания ядра приложение "Работа с Cache"
--------------
Кеш нам нужен, что бы не так сильно грузить нашу бд и производительность сайта
Создаем class Cache в папке src/Utils подключаем trait TSingletone что бы создался только один раз
И создаем 3 метода установить кеш set(), получить кеш get() и удалить кеш delete()
- При созданье кеша set($key, array $data, int $seconds = 3600)
мы задаем ключ (это название самого файла, предварительно зашифруем его с помощь md5 )
далее идет то что мы туда хотим положить оно идет массивом ну и на сколько времени в секундах по умолчанию 3600сек = 1 час
Ложем этот файл в папочку tmp/сache
- При получении  get(string $key) мы ищем этот файл, декодируем его и проверяем дата еше не устарела, если устарела, значит
файл уже не годен. И возвращаем false. При выходе делаем логику, пример в src/Controllers/TestController->cache()
- При удалении delete() просто удаляем этот кеш, если он существует.

Пример работы с кешом смотрим в src/Controllers/TestController->cache()

---------------
e) Часть пятое написание MVC создания ядра приложение "Базовый контролер"
--------------
От базового контролера идут все остальные контролеры, поэтому он будет у нас абстрактным.
Создаем abstract class Controller в папке src/Utils/Base. В нем пишем 4 свойства, которые будут принимать в себя данные.
В конструкторе мы помешаем в свойства data параметры, что бы можно было воспользоваться ими во фронтенте.
Создаем 3 свойства:
- getView() --- запускает класс new View и передает туда параметры: название шаблона, Название папки, где хранится вид и
метеоданные. Дальше запускаем метод во View->show($this->data) передав туда данные которые надо передать во фронтенд.
- setMeta() --- Создаем массив метеоданных и засовываем в свойства.
- view() --- Передает название папки вида и данные в свойства класса

---------------
f) Часть шестая написание MVC создания ядра приложение "Базовый вид"
--------------
Это базовый вид которые рендеринг страничку во фронтенд и передает туда данные, все осуществляется через контролер.
Создаем class View в папке src/Utils/Base. В нем пишем 4 свойства, которые будут принимать в себя данные.
В конструкторе получаем эти данные из базового контролера и передаем в свойства класса.
Проверяем шаблон layout пишем логику через тернальный оператор. Если с контролера что-то пришло в $layout(true )
значит его передаем, иначе передаем, то что в константе.
Пишем 2 метода:
- show($data) --- Этот метод запускается от контролера. Его главная задача редериг страничку и передает данные на фронтенд.
Он принимает в себя дату, то что передали с контролера массив. В нем переводим все в переменную(ключ= название переменой).
Дальше мы делим на работу с видом(template) и работу со шаблоном(layout).
Вид(template)--- Проверяем пришло ил что-то в template и мы находимся в режиме разработчика? Если нечего не прешло и режим
DEBUG, значит в вид подключаем шаблон, что такой стр нет. Иначе перекидываем название вида. А если условия не соблюдены
типа режим продакшене, то выкидываем ошибку.
Далее формируем путь для видео и проверяем есть ли такой файл с таким названием. Включаем буферизацию и передаем на
фронтенд, если что-то не то, выкидываем ошибку.
Шаблон(layout)--- Проверяем что-то пришло, формируем путь до шаблона. Проверяем есть ли такой файл, если нет то выкидываем
ошибку. Подключаем его. Если что-то не так, то выкидываем ошибку
- getMeta() --- формируем html код для мета и подставляем туда что пришло. Возвращаем на страничку

---------------
g) Часть седьмая написание MVC создания ядра приложение "Папочка view"
--------------
Работа с нашеми страницами (вид/шаблон)
структура папок и файлов
view -> errors (тут находятся шаблоны с ошибками)
.... -> layouts (наш шаблоны, то что не меняется/темы изменение типа ночной дневной вид)
.... -> main ( главная страница вида (то что в середине) и поеследуюшие папки это наш будет вид)
.... -> giglet_main.template.php (заглушка)
Тут все просто в наш шаблон в папке layouts просто подставляем данные и верезаем середину (вид) то что будет динамическая
часть сайта они будут находится по папкам

---------------
h) Часть восьмая написание MVC создания ядра приложение "Базовая модель"
--------------
Нужна для работы с бизнес логикой и с нашей бд
Для начало нам надо подключится к нашей бд, так как мы используем библиотеку RedBeanPHP
С помощью композера устанавливаем библиотеку RedBeanPHP
Дальше создаем class Db в папке src/Utils подключаем к нему use trait TSingletone
И в конструкторе подключаем наш конфигурационный файл (config_db.php) для бд в нем
---
return [
    'dsn' => 'mysql:host=172.25.0.6;dbname=app;charset=utf8',
    'user' => 'root',
    'pass' => 'test',
];
---
Далее подключаемся к бд подставляя данные, проверка подключили или нет, запись в лог.
Большинство функций RedBeanPHP на продакшене не нужны, поэтому дальше пишем в логике проверку, если в продакшене
то замораживает ненужные функции.

Потом создаем abstract class Model в папке src/Utils/Base.
Ее делаем абстрактной в конструкторе подключаем наш class Db.

---------------
i) Создание нашего блога......
--------------






