~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|...............................................................................................|
|------------------- Инструкция / алгоритм как я создал свой cms на базе mvc -------------------|
|...............................................................................................|
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

---------------------------------------- Содержание ---------------------------------------------

1) Настройка окружение "Docker - Compose"
2) Шаблон
3) Создание MVC и само построение на приложение

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

----------------------------------------- Основа -----------------------------------------------

-----------------------------------------
1) Настройка окружение "Docker - Compose"
-----------------------------------------
Определяемся что нам надо для нашего cms. А это сервер, возмем nginx. Сам язык интерпретатора php-fpm, и mysql.
Вообшем ставим что то подобное LEMP
https://maddot.ru/kak-ustanovit-lemp-v-ubuntu-20-04.html
Дальше нам нужен git и composer......

---------------
a) docker-compose.yml
---------------
Создаем файл с названием docker-compose.yml и в нем пишем
# так обозначаются комментарии
# С начало ставим версию докер композера
version: '3.7'

# Тут дальше идет какие мы сервисы хотим запустить.Так назваемая инструкция
# Название сервисов может быть любыми, но что бы было логически понятно какие там инструкции будут php: или mysql:
services:
# Ставим сервер
  nginx:
    build:
    # Указываем путь, где находятся настройки(правела установки) сервера
      context: ./docker/nginx
    volumes:
    # Прописываем путь к нашему проекту и контейнера, где ./ это является путь обращение этой папки на компе.
    # Двоеточие означает "к"  наш комп : виртуалка
      - ./:/var/www/app
    ports:
    # Прописываются порты. Что бы был такой адрес https://locallhost/ надо использовать 80 порт
      - "80:80"

# Дальше у нас идет интерпретатора языка
    php-fpm:
        build:
         # Указываем путь, где находятся настройки(правела установки) интерпретатора языка php
          context: ./docker/php-fpm
        volumes:
        # Прописываем путь к нашему проекту и контейнера, где ./ это является путь обращение этой папки на компе.
        # Двоеточие означает "к"  наш комп : виртуалка
          - ./:/var/www/app
        environment:
        # настройка XDEBUG для убунту/ phpstorm. Путь прописан к обращению .env файлу
          PHP_IDE_CONFIG: serverName=${SERVER_NAME}
        env_file:
        # путь для .env там находятся настройки/пароли/и т.д. нашего окружение. Эта строка работает для всего
          - .env
        networks:
          default:
          # Указываем ip для взаимодействия приложений между собой
            ipv4_address: ${PHP_FPM_IP}

# Далее идет у нас База данных mysql
    mysql:
    # Берем готовую сборку с https://hub.docker.com/
        image: mysql:8.0
        environment:
        # Задаем имя DATABASE и рутовский пароль. Он хранится в .env файле
          MYSQL_DATABASE: ${DB_NAME}
          MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
          # Задавать настройку, подробности тут
          # https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html#upgrade-caching-sha2-password-root-account
        command: --default-authentication-plugin=mysql_native_password
        volumes:
        # БД будет хранится в докере
          - mysql_data:/var/lib/mysql
          # копирование команд бд в папку вируализации (типа минималка которая должна быть на виртуализации таблица и заполнение ее)
          - ./init.sql:/docker-entrypoint-initdb.d/init.sql
        ports:
        # В каких портах работает 1 к 1
          - "3306:3306"
        networks:
          default:
          # ip адрес для взаимодействия между программ. Он хранится в .env файле
            ipv4_address: ${MYSQL_IP}

# Далее идет правела по взаимодейсвию между программ
    networks:
      default:
      #  по системе bridge совершается конекшон
        driver: bridge
        ipam:
          config:
          # нетворк между контенерами
            - subnet: ${NETWORK_SUBNET}
    volumes:
    # бд хранится в докере
      mysql_data:

---------------
b) Настройка nginx в docker/nginx
---------------
---
В Dockerfile пишем это
---
    # Задаем архетиктура из докерхаба https://hub.docker.com/
FROM nginx:1.21-alpine
    # указываем настройки копируются с- в
COPY ./conf.d /etc/nginx/conf.d
    # Указываем рабочию дерекцию в виртуалке
WORKDIR /var/www/app

---
Далее настройки нашего сервера они находятся в папке docker/nginx/conf.d/
Создаем фаил default.conf и пишем это
---
# Этот блок означает что мы будем обслуживать какой-то хост
server {
# слушаем порт постоянно. (рабочий порт)
    listen 80;
# Какие файлы считать по дефолту начальными что открыть
    index index1.php index.html;
# Наш адрес url
    server_name 127.0.0.1 localhost;
# С какой папкой работать. Где старт/ точка входа /Путь где будет искать index...
    root /var/www/app/public;

# Все запросы будут делатся только на index.php (обработка / )
    location / {
# Проверяет если не index.php то перенаправляет на index.php
        try_files $uri /index.php?$args;
    }

# Так как у нас нет в nginx php то благодоря композеру указываем путь на него (Обработка php )
    location ~ \.php$ {
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php-fpm:9000;
        fastcgi_index index1.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
    error_log /var/log/nginx/project_error.log;
    access_log /var/log/nginx/project_access.log;
}


---------------
c) Настройка интерпретатора языка php в docker/php-fpm
---------------
---
В Dockerfile пишем это
---
# Задаем архетиктура из докерхаба https://hub.docker.com/
FROM php:7.4-fpm-alpine

# Запускаем команды для дополнительной установки доп. программ (все то же самое что писать в командной строке в линуксе)
RUN apk update && apk add unzip autoconf g++ make \
    && pecl install xdebug \
    && docker-php-ext-install pdo_mysql && docker-php-ext-enable xdebug

# переименовываем фаил
RUN mv $PHP_INI_DIR/php.ini-development $PHP_INI_DIR/php.ini

# копируем с нашей папке в виртуалку настройки
COPY ./conf.d /usr/local/etc/php/conf.d
COPY www.conf /usr/local/etc/php-fpm.d/

# даем рутовские права (что бы было возможно создавать и удалять)
USER 1000:1000

# Рабочая директория
WORKDIR /var/www/app

---
Создаем фаил www.conf это конфигурационный файл для нашего php
---
[www]
user = www-data
group = www-data
clear_env = no
listen = 9000
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3

---
Создаем файл xdebug.ini в папке docker/php-fpm/conf.d
---
[xdebug]

xdebug.start_with_request = yes
xdebug.discover_client_host = 1
# Для хоршого отображение
xdebug.mode= debug, develop
# порт стандарт 9003
xdebug.client_port= 9003
#  172.17.0.1 хост для удаленной отладки ifconfig ишем раздел docker0:
xdebug.client_host= 172.17.0.1
# что бы подсветка была красивая
integer xdebug.cli_color = 1
# Принцепи это есть в env файл но решил еше сюда добавить
xdebug.idekey= PHPSTORM


---------------
d) Файл .env
---------------
В файле .env  тут у нас хранятся настройки/ пароли именно для нашей рабочей среды. При необходимости мы можем его легко изменить

# Настройки MySQL для входа
DB_PASSWORD=test
DB_NAME=app

# нетворк между контенерами
NETWORK_SUBNET=172.25.0.0/24
PHP_FPM_IP=172.25.0.3
MYSQL_IP=172.25.0.6

# настройки XDEBUG для убунту/ phpstorm
SERVER_NAME=www

Создаем фаил .env-example для гита, там будет пример настроек

---------------
d) Файл init.sql
--------------
---
Создаем файл init.sql для нашей бд что бы создалось первоначальные база данных для работы с нашем приложение
---

CREATE USER 'admin'@'172.25.0.6' IDENTIFIED BY 'test';
GRANT ALL ON *.* TO 'admin'@'172.25.0.6';
FLUSH PRIVILEGES;
# Если нажна таблица вот пример как ее создать в коментарии
# CREATE TABLE test (
#                          id int auto_increment primary key,                           col1 datatype,
#                         tile varchar(255) not null
# );
# INSERT INTO test(tile)
#      VALUES
#       ('text1'), ('text2');

---------------
e) Файл .gitignore
--------------
---
Ну тут все просто. Файлы которые недолжны попасть в гитхаб
---
.idea/
.env
vendor/

---------------
f) Файл composer.json
--------------
{
  "authors": [
    {
      "name": "Pasha Karpunin",
      "email": "amedomaro2@gmail.com"
    }
  ],

  "autoload": {
    "psr-4": {
      "App\\": "src/"
    },
    "files": ["helpers.php", "config/init.php"]
  },

  "require": {
    "gabordemooij/redbean": "dev-master"
  }
}

---------------
g) Структура папок проекта
--------------
src -> Controllers
.... -> Models
.... -> Utils
tmp-> cache
view -> errors
.... -> layouts
.... -> main
vendor - (автоматически появится)
public -> pic
  .... -> css
  .... -> js
config

Это первоначальная струкрура папок, далее мы будем добовлять по мере необходимости
---------------
h) Запуск "Docker - Compose"
--------------
Для запуска сначала билдем что бы создать образ
#       docker-compose build

Это делается один раз что бы создать образ, можно конечно сразу его запустить с помошю команды docker-compose up --build
Но иногда происходит артефакты. Поэтому просто сначало билд. Потом запуск
#       docker-compose up

Для проверки в файле index.php вставляем этот код
---

// phpinfo();

//ini_set('xdebug.var_display_max_children', 3 );
//$c = new stdClass;
//$c->foo = 'bar';
//$c->file = fopen( '/etc/passwd', 'r' );
//var_dump(
//    array(
//        array(TRUE, 2, 3.14, 'foo'),
//        'object' => $c
//    )
//);

---
Проверяем что все работает, все ок !!!
Теперь устанавливаем composer, что бы все зависимости и автолоудер у нас работал
#       composer install

Появляется папочка vendor, значит все ок, все установилась.
Что бы обновить свои данные там, даме команду
#       composer dumpautoload

Когда все закончили работу, останавливаем докер.
#       docker-compose down

---------------
i) Настройка IDE PhpStorm для адекватного работы xdebug
---------------
Инструкция настройки PhpStorm. Для нашего случая инструкция немного изменена
 https://blog.denisbondar.com/post/phpstorm_docker_xdebug

 File — Settings -Build, Execution, Deployment» — Docker
 Проверяем что бы был нажат плюсик name = Docker, Connect to Doc.... = Unix socket
 Connection successful

 File — Settings - PHP
 Выбираем нашу версию пышки которая указана в Docker Compose
 Справа от CLI Interpreter нажмите кнопку с тремя точками.
 В открывшемся окне CLI Interpreters нажмите плюс слева вверху и выберите там From Docker….
 Далее нужно выбрать Docker Compose
 Сервер = докер
 конфигурационный файл указав наш путь к docker-compose.yml
в сервисе выберем php-fpm
 Далее ок

 В открывшимся окне задаем имя нашего Docker Php 8.0, рядом ставим галочку visible only for this....
 Далее галочка в Connect to existent container
 И у нас внизу должно быть все указано если нет то нажимает ок и можем проделать все то же самое (добавить)
 но ставим php-cli опцию Always start a new container
 По идеи, что то должно произойти и оно должно все отобразить

 Path mappings берется из docker-compose.yml (проверяем путь в этом окне File — Settings - PHP )
 Папка на локальном где лежит наш проэкт vs папка которая записано в docker-compose.yml куда перекидывает наш проэкт

 File — Settings - PHP - Debug. И нажмите на ссылку Validate.
  должны указать полный путь к web-корню (в нашем примере это подкаталог проекта public)
 адрес сервера (в нашем примере порт 80 контейнера nginx укажите обязательно его http://127.0.0.1,или например, http://127.0.0.1:8080). Нажмите Validate.
 Это проверка настроено все верно да или нет.

 File — Settings - PHP - Servers нажмите плюсик, чтобы добавить новый.
 Укажите имя сервера www (должно совпадать с переменной окружения PHP_IDE_CONFIG в docker-compose.yml) и хост 127.0.0.1.
Пропишете или проверти мапинг  /var/www/app

 В главном меню Run перейдите в Edit configurations…
 Нажмите плюсик вверху слева и выбирайте PHP Web page. Укажите имя для данной страницы, например, WWW,
 затем укажите сервер, с которым связана эта страница (мы создали его на предыдущем шаге) и нажмите OK.

Проверяем работу xdebug
Теперь приступаем к работе.


-----------------------------------------
2) Шаблон
-----------------------------------------
Теперь нам нужен шаблон, что бы на него одеть нашу cms
Но для начало нам надо продумать сайт что там будет и как он будет выглядеть.
На листочке бумаге рисуем все что хотим, а дальше по ходу дорабатываем.
Будем использовать Bootstrap

---------------
a) Главная страница
--------------
Тут все просто, делим сайт на шаблон (то что неизменно, нав и футер) и вид (это середина, которая будет постоянно меняться)
1) Берем стандарт с сайта Bootstrap
2) подключаем шрифт стили js
4) Создаем <header> тут будет у нас логиниться, потом главное название проекта <h1> и navbar.
Его берем из стандартного шаблона Bootstrap и немного обновляем и подправляем, подводим до себя.
5) Создаем середину сайта main тут у нас будет все динамически меняться, так как это блог сюда выставим типа одной карточки
с переходами по темам. Но для начало поместим сверху название, что это за раздел  <h2> потом сам блог(карточку).
Затем переходы на следующею страницу и подняться быстро на верх.
6) Создаем <footer> тут все просто, все стандартно.

---------------
b) Главная страница
--------------
Добовляем вкладку добавить это у нас будет видом, немного подправляем и изменяем предыдущею страницу.
В середину добавляем поля и все наш шаблонщик готов.
Дальше по ходу, что-то подправим, если будет надо....

-----------------------------------------
3) Создание MVC и само построение на приложение
-----------------------------------------
Мы запостили и проверяли работоспособность нашего окружение, теперь будем писать наше ядро приложение !!!

---------------
а) Часть первая написание MVC создания ядра приложение "Начальные файлы, создание роутер"
--------------
Создаем стартовый класс и от туда будем писать роутер.
Так как все стартует с public/index.php
там пишем стандартный код:
Вывод ошибок
---
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);
---

Подключение автолоудера
---
require __DIR__ . '/../vendor/autoload.php';
---
В нем мы добавили 2 файла
config/init.php      ---   Фаил конфигурации для легкого кодирование (тут у нас константы с путями и немного конфигурации) См сам файл, за подробностями.
helpers.php          ---   Дополнительные функции которые могут пригодиться для всего приложение. См сам файл, за подробностями.
Эти файлы доступны везде так как они подключены к нашему индексу, они вспомогательные.

Дальше создаем класс new App(); в папке src/Utils . В этом файле будут поочередно запускаться все наши классы которые
и будет состоять наше приложение.
В конструкторе стартуем сессию, и создаем класс роутера
---
public function __construct()
    {
        // Стартуем сессию
        session_start();
        // Подключаем наш роутер (маршрутизатор)
        $router = new Router();
        // Запускаем метод
        $router->process();
    }
---
Создаем наш Router в папке src/Utils
Метод process() отсюда будет стартовать наш роутер. Принцип прост, разбиваем нашу сылку на контролер и метод.

Получаем PATH от ссылки, разбиваем ссылку на массив по элементам. 0 ключ - это пустота, 1 - контролер, 2 - экшон(метод)
Формируем полный неймспейс класса, если нечего не пришло, то тогда будет HomeController, если что-то пришло по сылке,
значит прописываем полный путь к этому файлу, название ставим заглавной буквы и добавляем слово Controller
Далее проверяем существует ли этот класс у нас, если нет кидаем эксепшон.
Теперь дело за методом. Если нечего по сылке не пришло, значит подставляем метод index. А если пришло, то значит его
Потом проверяем есть ли в классе этот метод. И все это закидываем в метод getAction(), который возвращает массив из
класса и метода.

В методе process() мы запускаем метод getAction() и получаем массив класса с методом, что нам надо запустить.
Подставляем и запускаем.
Проверяем на работоспособность, создав при этом HomeController и TestController

---------------
b) Часть вторая написание MVC создания ядра приложение "Модуль с ошибками"
--------------
Создаем class ErrorHandler в src/Utils Этот класс будет отвечать за обработку ошибок на нашем приложении
В  __construct() пишем логику отображении ошибок, если мы в продакшене их не отображаем. А если в разработке отображаем.
Далее запускаем callback функцию set_exception_handler(); и в нем мы запускаем наш метод exceptionHandler
и передаем через callback функцию ошибка которая пришла.
Далее запускаем в ней 2 метода:
logErrors() --- Создает лог файл в папке /tmp/errors.log и туда помешает в красивой форме какие ошибки произошли.
displayError() --- Он проверяем в каком режиме мы в разработке или продакшоне. Если в продакшене, то в случае ошибки
перекидывает нас на страничку 404 /errors/404.template.php
Если режиме разработки то красиво показывает ошибку в красивой форме /errors/dev.template.php
Иначе если мы в продакшене и это не 404 ошибка то выводит для пользователя другую страницу с ошибки /errors/prod.template.php

Что бы узнать в каком мы режиме в файле config/init.php указана константа DEBUG. Она в true или false

---
коды ошибок для указания какая ошибка что означает
https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
---

1xx: Informational (информационные):
100 Continue («продолжай»)
101 Switching Protocols («переключение протоколов»)
102 Processing («идёт обработка»);
103 Early Hints («ранняя метаинформация»);
2xx: Success (успешно):
200 OK («хорошо»)
201 Created («создано»)
202 Accepted («принято»)
203 Non-Authoritative Information («информация не авторитетна»)
204 No Content («нет содержимого»)
205 Reset Content («сбросить содержимое»)
206 Partial Content («частичное содержимое»)
207 Multi-Status («многостатусный»)
208 Already Reported («уже сообщалось»)
226 IM Used («использовано IM»).
3xx: Redirection (перенаправление):
300 Multiple Choices («множество выборов»)
301 Moved Permanently («перемещено навсегда»)
302 Moved Temporarily («перемещено временно»), 302 Found («найдено»)
303 See Other («смотреть другое»);
304 Not Modified («не изменялось»);
305 Use Proxy («использовать прокси»);
306 — зарезервировано (код использовался только в ранних спецификациях);
307 Temporary Redirect («временное перенаправление»);
308 Permanent Redirect («постоянное перенаправление»).
4xx: Client Error (ошибка клиента):
400 Bad Request («неправильный, некорректный запрос»);
401 Unauthorized («не авторизован (не представился)»);
402 Payment Required («необходима оплата»);
403 Forbidden («запрещено (не уполномочен)»)
404 Not Found («не найдено»);
405 Method Not Allowed («метод не поддерживается»);
406 Not Acceptable («неприемлемо»);
407 Proxy Authentication Required («необходима аутентификация прокси»)
408 Request Timeout («истекло время ожидания»);
409 Conflict («конфликт»)
410 Gone («удалён»)
411 Length Required («необходима длина»)
412 Precondition Failed («условие ложно»)
413 Payload Too Large («полезная нагрузка слишком велика»)
414 URI Too Long («URI слишком длинный»)
415 Unsupported Media Type («неподдерживаемый тип данных»)
416 Range Not Satisfiable («диапазон не достижим»)
417 Expectation Failed («ожидание не удалось»)
418 I’m a teapot («я — чайник»);
419 Authentication Timeout (not in RFC 2616) («обычно ошибка проверки CSRF»);
421 Misdirected Request
422 Unprocessable Entity («необрабатываемый экземпляр»);
423 Locked («заблокировано»);
424 Failed Dependency («невыполненная зависимость»);
425 Too Early («слишком рано»);
426 Upgrade Required («необходимо обновление»);
428 Precondition Required («необходимо предусловие»)
429 Too Many Requests («слишком много запросов»)
431 Request Header Fields Too Large («поля заголовка запроса слишком большие»)
449 Retry With («повторить с»)[1];
451 Unavailable For Legal Reasons («недоступно по юридическим причинам»)
499 Client Closed Request (клиент закрыл соединение);
5xx: Server Error (ошибка сервера):
500 Internal Server Error («внутренняя ошибка сервера»)
501 Not Implemented («не реализовано»)
502 Bad Gateway («плохой, ошибочный шлюз»)
503 Service Unavailable («сервис недоступен»)
504 Gateway Timeout («шлюз не отвечает»)
505 HTTP Version Not Supported («версия HTTP не поддерживается»)
506 Variant Also Negotiates («вариант тоже проводит согласование»)
507 Insufficient Storage («переполнение хранилища»);
508 Loop Detected («обнаружено бесконечное перенаправление»)
509 Bandwidth Limit Exceeded («исчерпана пропускная ширина канала»);
510 Not Extended («не расширено»);
511 Network Authentication Required («требуется сетевая аутентификация»)
520 Unknown Error («неизвестная ошибка»)
521 Web Server Is Down («веб-сервер не работает»)
522 Connection Timed Out («соединение не отвечает»);
523 Origin Is Unreachable («источник недоступен»)
524 A Timeout Occurred («время ожидания истекло»);
525 SSL Handshake Failed («квитирование SSL не удалось»)
526 Invalid SSL Certificate («недействительный сертификат SSL»)

---------------
c) Часть трития написание MVC создания ядра приложение "Создание контейнера"
--------------
Создаем trait TSingletone - Этот трейл будет реализовывать нам патерн Singletone, создает один раз объект.
Так как мы недолжные создать более чем одного объекта данного класса. Для этого мы создаем свойства приватное,
это свойства заполняем объектом, если его там нет. Пишем логику если у нас свойства текущего класса пуста null
то тогда мы в него положим объект данного класса. И вернем это свойство обратно (там всегда будет этот класс обЪекта
который подключен этот trait)
Создаем наш class Registry к нему подключаем trait TSingletone и создаем наш контейнер для свойств
 protected static $properties = [];
Мы будем туда засовывать то что есть в файле config/params.php и добавлять дополнительные параметры(свойства) в этот контейнер
по мере надобности.
В class Registry пишем 3 метода:
setProperty() --- Добавить свойства
getProperty() --- Получить от туда свойства
etProperties()--- Просмотреть все свойства, что там есть
В файле config/params.php по мере необходимости будем его заполнять. Для теста напишем это:
---
return [
    'admin_email' => 'admin@gmail.com',
    'site_name' => 'Блог для подготовки php собеседований'
];
---
В class App запускаем через этот регистр
---
        // Подключаем наш реестр (в нем мы можем хранить все наши параметры)
        self::$app = Registry::instance();
        // Вызываем getParams что бы заполнить контейнер Registry::instance данными
        $this->getParams();
---
и там же создаем еше один метод getParams() что бы засунуть параметры config/params.php в контейнер, о чем мы говорили
ранее. С начало подключаем их потом через цикл добавляем self::$app->setProperty($k,$v);


---------------
d) Часть четвертая написание MVC создания ядра приложение "Работа с Cache"
--------------
Кеш нам нужен, что бы не так сильно грузить нашу бд и производительность сайта
Создаем class Cache в папке src/Utils подключаем trait TSingletone что бы создался только один раз
И создаем 3 метода установить кеш set(), получить кеш get() и удалить кеш delete()
- При созданье кеша set($key, array $data, int $seconds = 3600)
мы задаем ключ (это название самого файла, предварительно зашифруем его с помощь md5 )
далее идет то что мы туда хотим положить оно идет массивом ну и на сколько времени в секундах по умолчанию 3600сек = 1 час
Ложем этот файл в папочку tmp/сache
- При получении  get(string $key) мы ищем этот файл, декодируем его и проверяем дата еше не устарела, если устарела, значит
файл уже не годен. И возвращаем false. При выходе делаем логику, пример в src/Controllers/TestController->cache()
- При удалении delete() просто удаляем этот кеш, если он существует.

Пример работы с кешом смотрим в src/Controllers/TestController->cache()

---------------
e) Часть пятое написание MVC создания ядра приложение "Базовый контролер"
--------------
От базового контролера идут все остальные контролеры, поэтому он будет у нас абстрактным.
Создаем abstract class Controller в папке src/Utils/Base. В нем пишем 4 свойства, которые будут принимать в себя данные.
В конструкторе мы помешаем в свойства data параметры, что бы можно было воспользоваться ими во фронтенте.
Создаем 3 свойства:
- getView() --- запускает класс new View и передает туда параметры: название шаблона, Название папки, где хранится вид и
метеоданные. Дальше запускаем метод во View->show($this->data) передав туда данные которые надо передать во фронтенд.
- setMeta() --- Создаем массив метеоданных и засовываем в свойства.
- view() --- Передает название папки вида и данные в свойства класса

---------------
f) Часть шестая написание MVC создания ядра приложение "Базовый вид"
--------------
Это базовый вид которые рендеринг страничку во фронтенд и передает туда данные, все осуществляется через контролер.
Создаем class View в папке src/Utils/Base. В нем пишем 4 свойства, которые будут принимать в себя данные.
В конструкторе получаем эти данные из базового контролера и передаем в свойства класса.
Проверяем шаблон layout пишем логику через тернальный оператор. Если с контролера что-то пришло в $layout(true )
значит его передаем, иначе передаем, то что в константе.
Пишем 2 метода:
- show($data) --- Этот метод запускается от контролера. Его главная задача редериг страничку и передает данные на фронтенд.
Он принимает в себя дату, то что передали с контролера массив. В нем переводим все в переменную(ключ= название переменой).
Дальше мы делим на работу с видом(template) и работу со шаблоном(layout).
Вид(template)--- Проверяем пришло ил что-то в template и мы находимся в режиме разработчика? Если нечего не прешло и режим
DEBUG, значит в вид подключаем шаблон, что такой стр нет. Иначе перекидываем название вида. А если условия не соблюдены
типа режим продакшене, то выкидываем ошибку.
Далее формируем путь для видео и проверяем есть ли такой файл с таким названием. Включаем буферизацию и передаем на
фронтенд, если что-то не то, выкидываем ошибку.
Шаблон(layout)--- Проверяем что-то пришло, формируем путь до шаблона. Проверяем есть ли такой файл, если нет то выкидываем
ошибку. Подключаем его. Если что-то не так, то выкидываем ошибку
- getMeta() --- формируем html код для мета и подставляем туда что пришло. Возвращаем на страничку

---------------
g) Часть седьмая написание MVC создания ядра приложение "Папочка view"
--------------
Работа с нашеми страницами (вид/шаблон)
структура папок и файлов
view -> errors (тут находятся шаблоны с ошибками)
.... -> layouts (наш шаблоны, то что не меняется/темы изменение типа ночной дневной вид)
.... -> main ( главная страница вида (то что в середине) и поеследуюшие папки это наш будет вид)
.... -> giglet_main.template.php (заглушка)
Тут все просто в наш шаблон в папке layouts просто подставляем данные и верезаем середину (вид) то что будет динамическая
часть сайта они будут находится по папкам

---------------
h) Часть восьмая написание MVC создания ядра приложение "Базовая модель"
--------------
Нужна для работы с бизнес логикой и с нашей бд
Для начало нам надо подключится к нашей бд, так как мы используем библиотеку RedBeanPHP
С помощью композера устанавливаем библиотеку RedBeanPHP
Дальше создаем class Db в папке src/Utils подключаем к нему use trait TSingletone
И в конструкторе подключаем наш конфигурационный файл (config_db.php) для бд в нем
---
return [
    'dsn' => 'mysql:host=172.25.0.6;dbname=app;charset=utf8',
    'user' => 'root',
    'pass' => 'test',
];
---
Далее подключаемся к бд подставляя данные, проверка подключили или нет, запись в лог.
Большинство функций RedBeanPHP на продакшене не нужны, поэтому дальше пишем в логике проверку, если в продакшене
то замораживает ненужные функции.

Потом создаем abstract class Model в папке src/Utils/Base.
Ее делаем абстрактной в конструкторе подключаем наш class Db.

---------------
i) Создание нашего блога......
--------------
Наше ядро создано, теперь создаем:
1) контролеры
2) обложку
3) модельку
4) убеждаемся что все работает и начинаем дорабатывать систему...

---------------
i.1)  Controller
--------------
Так как начало мы забили на HomeController extends Controller с него мы начнем. В каждом контролере должна быть обезательная
заполненая запись.
---
      // мета данные
      $this-> setMeta (
          'title',
          'desc',
          'keywords'
      );
      //  подключает шаблон и передача данных на внешний вид
      $this-> view('main.main', $data);
---

Делаем еше один контролер для теста всего cms и функционала class TestController extends Controller
Тестируем и испытываем, см. сам контролер

---------------
i.2)  layouts/view
--------------
Когда у нас контролер есть и мы проверели функционал на работуспособность, подключаем внешний вид сайта
В папочке layouts у нас 2 файла. Если нам надо сменить тему/оформление (светлую/темную) нашего шаблона. Для проверки
просто меняем бэкграунт на темный
Теперь ставим середину, в папочке main это будет главная страница, в папочке add это будет добавить запись в бд
Разбиваем код, и добовляем в файл. Для ошибок создаем середину (вид) giglet_main.template.php там мы будем распечатывать
консоль команд в бд.
Тестем все на работоспособность с помощь контролера TestController.

---------------
i.3)  Model
--------------
Теперь будем работать с нашей бд
Создаем 2 модельки class Blog extends Model --- для нашего cms  и class Test extends Model  --- для теста redbeanphp
Тестируем функционал/ возможности redbeanphp


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
i.4)  Продолжение работы/ основная разработка нашего приложение
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Убедились что все работает продумать как все будет выглядеть (бизнес логика) ---постоянно переписывая код---
Разбиваем задачи на модули(функционал) и добавляем его постепенно в наш проект. Когда убедились что эта реализация
подходит, после этого записали эту реализацию в конспект.
---------------
План разбития подзадач
--------------
1) Добавления записи в бд
    a) Создание контролера
    b) Проверка приходит данных и чем "метод start()"
    c) Передача валидированых данных в модель "Метод add"
    d) Валидация данных "Метод validation"
    e) Переход в модель(бд) Создание таблици
2) Вывод информации на странице сайта
    a) Получение из бд - метод load
    b) вывод на вьюшку
    c) Тема тега или выбор страниц
    d) Обшей контролер "TypeController"
    e) HomeController
    f) PracticeController


---------------
i.4.1.a) Добавления записи в бд "Создание контролера"
--------------
Создаем контролер class AddController extends Controller в папке src/Controller
Для загрузки данных что бы можно с ними работать и понять как система будет вообще работать, так сказать архитектура
В конструкторе добавляем в свойства новый класс моделька new Blog() что бы можно было работать с бд.
Так как в нашем роутере все методы начинаются с index(), это наш стартовый метод.
Так как один метод может запускать и страничку и добавляет данные в бд, мы ставим проверку каким запросом пришло
Если гет, значит вопрошаем рендеринг странички. Если постом, то получаем данные, валидируем, отправляем в модельку
и получаем ответ ок или не ок и на основе этого пишем сообщение как все прошло.

---------------
i.4.1.b) Добавления записи в бд "метод start()"
--------------
Когда получили данные постом то, запускаем метод start()
Проверяем что какая кнопка была нажата $_POST['send'] или $_POST['dell'] и должно что-то прийти, потом проверка на пустоту
Если в массиве нечего нет то возвращаем пустою строку. Вызываем соответсвующий метод и передаем туда эти данные.
Если проверка не пройдена, выкидываем эксепшон.
На кнопке $_POST['dell'] делаем метод dell($type, $postId); а в самом методе пустышку, для проверки работоспособности.

---------------
i.4.1.c) Добавления записи в бд "Метод add"
--------------
Метод add создает или обновляем таблицу. Для начало мы реализуем создание таблици....
Сразу в нем мы валидируем пришедшие нам данные в методе validation
Потом то пришло от метода validation мы перекидываем все в модельку Blog() метод create и передаем туда проваледированые данные

---------------
i.4.1.d) Добавления записи в бд "Метод validation"
--------------
Метод validation тут идет проверка данных.

---------------
i.4.1.e) Добавления записи в бд или переход в модель(бд) Создание таблици "Метод create"
--------------
Теперь переходим к файлу в папке src/Model/class Blog extends Model
Создаем метод create, мы будем использовать метод many to many в Redbean. Создаем таблицу и подставляем данные, возрашаем id таблици
Примечание в документации, может вернуть строку.
Так как тег у нас повторяется, используем findOrCreate.

---------------
i.4.2) Вывод информации на странице сайта
--------------
Заполнили данные в таблицу, теперь выводим эти данные в разделе в "Теория" и "Практика"
Вывод данных на страницу. Будем выводить по темам определенного раздела. Темы это нормер id в теги. И это будет
у нас страница. Сделаем главный контролер, его назовем TypeController, тут будет все обшие и из него будев  переходить в
HomeController и PracticeController. Дальше все передается в шаблом/вьюшку.


---------------
i.4.2.a) Вывод информации на странице сайта "Получение из бд - метод load"
--------------
В HomeController мы дергаем нашу модельку Blog метод load($themes, $index), где $themes - это название колонки (теория/практика)
а $index - это id тега, которую тематику мы будем загружать. По умолчанию будет равной 1.
В class Blog extends Model, который находится в src/Model. Создаем метод load. В нем мы сначала создаем динамическое
название свойств. Далее загружая список тегов, который есть в бд. Проходимся по этому списку(массив) циклом через foreach,
формируя новый массив который состоит из id и переформатируя в обычный массив(убираем бимы).
Далее проверяем что есть такое число, которое получили с id массива. Если нет, то $index = 1.
Далее проверка есть у выбранного бина свойства получаем true или false. Если нету значит этот тег не принадлежит к этому разделу
После всех проверок мы проходимся по массиву(бина) циклом и создаем новый массив данных которые должны передать во вьюшку,
предварительно переведя его в обычный массив.
Добавляем к этому массиву, что за тег выбран. Все возвращаем.

---------------
i.4.2.b) Вывод информации на странице сайта "Вывод на вьюшку"
--------------
В HomeController, то что получили выводим во вьюшку в main.template.php. С помошью цикла подставляем данные и тестим.

---------------
i.4.2.c) Вывод информации на странице сайта "Тема тега или выбор страниц"
--------------
Так как в таблице тегов там идут темы в таблицу теории и практики, надо отсортировать их и это будет наши страници выбора внизу
Для этого, в модельке Blog, метод tag, мы сначало проверим, что за тему странице нам прейдёт. И от этой темы загрузим промежуточную
таблицу. Если нет такой, то выдадим ошибку.
Загружаем эту промежуточную таблицу id, уделяем повторяющиеся элементы и обнуляем ключи массива. С помощью цикла приводим этот массив
в красивый вид. И отправляем обратно в контролер. Там мы помешаем это в массив $data['page'] и передаем во вьюшку.
Во вьюшке (main.template.php) там где выбор странице с помощью цикла подставляем, где ключ это номер странице, а значение
будет у нас гет параметром.
И получается нажимая на номер странице мы будем дергать id который приедет через гет парамер заданной темы!

---------------
i.4.2.d) Вывод информации на странице сайта "Обшей контролер - TypeController"
--------------
Так как код одинаковый будет что в HomeController и PracticeController мы создадим TypeController
И общий код положим туда
В конструкторе добавим модельку $this->nameModal = new Blog();
В методе dbData мы будем работать с моделькой и вызовем метод tag и load в модельке. Все это красиво засунем в массив и вернем.
В методе getReqParam проверяет Гет параметр

---------------
i.4.2.e) Вывод информации на странице сайта "HomeController"
--------------
class HomeController extends TypeController это у нас главная страница контролера, тут у нас будет вывод теории.
Мы вызовем метод getReqParam он в TypeController. Этот метод проверяет что бы что-то пришло в гет параметре.
Если там пусто он выдаст ключ массива который надо для загрузки заданной странице темы
Далее мы формируем массив $data сначала туда мы передаем дискрипшон странички, потом с помощь функции array_merge,
мы соединяем массив. Которые получили при вызове метода dbData в TypeController с массивом $data
и передаем все во вьюшку. Тестем, все работает ...

---------------
i.4.2.f) Вывод информации на странице сайта "PracticeController"
--------------
Все то же самое что и в HomeController, только меняем тему странице/название таблице на practice и подставляем данные
для practice.

---------------------------------------
Дальше регистрация
https://www.youtube.com/watch?v=vvgOPJQA8Zk
















